// referred to https://github.com/iden3/circomlibjs/blob/v0.0.8/src/poseidon_slow.js

// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.9;

// import '../poseidon_constants.json' as Constants;

contract Poseidon {

    event Hashed(uint amount, uint when);

	// Prime 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001
	int256 F = 21888242871839275222246405745257275088548364400416034343698204186575808495617;

	// Using recommended parameters from whitepaper https://eprint.iacr.org/2019/458.pdf (table 2, table 8)
	// Generated by https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/calc_round_numbers.py
	// And rounded up to nearest integer that divides by t
    uint256 public N_ROUNDS_F = 8;
	uint256[16] public N_ROUNDS_P = [56, 57, 56, 60, 60, 63, 64, 63, 60, 66, 60, 65, 70, 60, 64, 68];

	// Parameters are generated by a reference script https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/generate_parameters_grain.sage
	// Used like so: sage generate_parameters_grain.sage 1 0 254 2 8 56 0x30644e72e131a029b85045b68181585d2833e84879b9709143e1f593f0000001
	// uint256 C = Constants[0];
	// uint256 M = Constants[1];

	function mul(int256 n, int256 m) internal pure returns(int256) {
		return (n*m)%F;
	}

	function suq(int256 n) internal pure returns(int256) {
		return (n*n)%F;
	}


	function add(int256 a, int256 b) internal pure returns(int256) {
		int res = a + b;
		return res >= F? res - F : res;
	}

	function pow5(int256 n) internal pure returns(int256) {

		int256 pow2 = suq(n);
		int256 pow4 = suq(pow2);
		return mul(n, pow4);
	}

	/* original implementation of e() in js
		e(a,b) {
			let res;
			if (!b) {
				res = BigInt(a);
			} else if (b==16) {
				res = BigInt("0x"+a);
			}
			if (res < 0) {
				let nres = -res;
				if (nres >= this.p) nres = nres % this.p;
				return this.p - nres;
			} else {
				return (res>= this.p) ? res%this.p : res;
			}
		}
	*/

	function e(int256 a) internal pure returns (int256) {

		if (a < 0) {
            int256 nres = -a;
            if (nres >= F) {
				nres = nres % F;
        	}
			return F - nres;
		} else {
            return (a>= F) ? a%F : a;
        }
	}
	/* original implementation of eq() in js
		eq(a, b) {
			const pa = this.reduce(a);
			const pb = this.reduce(b);

			if (pa.length != pb.length) return false;
			for (let i=0; i<pb.length; i++) {
				if (!this.F.eq(pa[i], pb[i])) return false;
			}

			return true;
		}
	*/

	function eq(int256 a, int256 b) pure internal returns(int256) {
		int256 ps = reduce(a);
		int256 pb = reduce(b);

		if(pa.length != pb.length)
			return false;
		for (int i=0; i<pb.length; i++) {
			if (eq(pa[i], pb[i]))
				return false;
		}
		return true;
	}

    function poseidon_hash(int256[] memory inputs) public pure returns(int256) {

        require(inputs.length > 0, "No input");
		require(inputs.length <= N_ROUNDS_P.length);

		uint256 t = inputs.length + 1;
   		uint256 nRoundsF = N_ROUNDS_F;
    	uint256 nRoundsP = N_ROUNDS_P[t - 2];
		int256[] storage state;

		state.push(0);

		for(uint i = 0; i < inputs.length; i++) {
			state.push(e(inputs[i]));
		}

		for (uint r = 0; r < nRoundsF + nRoundsP; r++) {
			for (uint i = 0; i <state.length; i++) {
				state[i] = state[i] + C[t-2][r * t + 1];
			}

			if (r < nRoundsF /2 || r >=  nRoundsF / 2 + nRoundsP) {
				for (uint i = 0; i <inputs.length; i++) {
					state[i] = pow5(state[i]);
				}
			} else {
				state[0] = pow5(state[0]);
			}

			/* original code
			state = state.map((_, i) =>
            state.reduce((acc, a, j) => F.add(acc, F.mul(M[t - 2][i][j], a)), F.zero)
        	);

			reduce((accumulator, currentValue, currentIndex) => { }, initialValue)

			*/

			uint start = 0;
			for (uint i = 0; i <state.length; i++) {
				uint multiple = mul(M[t - 2][i][i], state[i]);
				uint sum = add(start, multiple);
				start = multiple;
			}
		}

    }
}
